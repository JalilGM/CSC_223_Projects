using Xunit;
using Containers;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Utilities.Tests
{
    /// <summary>
    /// Comprehensive test suite for the DLL (Doubly Linked List) implementation.
    /// Tests cover all public methods, edge cases, boundary conditions, and error scenarios.
    /// </summary>
    public class DLLTests
    {
        #region Constructor Tests

        [Fact]
        public void Constructor_CreatesEmptyList()
        {
            // Arrange & Act
            var list = new DLL<int>();

            // Assert
            Assert.Equal(0, list.Count);
            Assert.True(list.IsEmpty());
        }

        [Fact]
        public void Constructor_InitializesSentinelNodes()
        {
            // Arrange & Act
            var list = new DLL<string>();

            // Assert - Should not throw when accessing front/back on empty list
            Assert.Throws<InvalidOperationException>(() => list.Front());
            Assert.Throws<InvalidOperationException>(() => list.Back());
        }

        #endregion

        #region PushFront Tests

        [Fact]
        public void PushFront_AddsElementToEmptyList()
        {
            // Arrange
            var list = new DLL<int>();

            // Act
            list.PushFront(5);

            // Assert
            Assert.Equal(1, list.Count);
            Assert.Equal(5, list.Front());
            Assert.Equal(5, list.Back());
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(100)]
        public void PushFront_AddsMultipleElements_MaintainsCorrectOrder(int count)
        {
            // Arrange
            var list = new DLL<int>();

            // Act
            for (int i = 0; i < count; i++)
            {
                list.PushFront(i);
            }

            // Assert
            Assert.Equal(count, list.Count);
            Assert.Equal(count - 1, list.Front()); // Last pushed is at front
            Assert.Equal(0, list.Back()); // First pushed is at back
        }

        [Fact]
        public void PushFront_WithNullValue_WorksForNullableTypes()
        {
            // Arrange
            var list = new DLL<string?>();

            // Act
            list.PushFront(null);
            list.PushFront("test");

            // Assert
            Assert.Equal(2, list.Count);
            Assert.Equal("test", list.Front());
            Assert.Null(list.Back());
        }

        [Fact]
        public void PushFront_WithDuplicates_AllowsMultipleSameValues()
        {
            // Arrange
            var list = new DLL<int>();

            // Act
            list.PushFront(5);
            list.PushFront(5);
            list.PushFront(5);

            // Assert
            Assert.Equal(3, list.Count);
            Assert.Equal(5, list.Front());
            Assert.Equal(5, list.Back());
        }

        #endregion

        #region PushBack Tests

        [Fact]
        public void PushBack_AddsElementToEmptyList()
        {
            // Arrange
            var list = new DLL<int>();

            // Act
            list.PushBack(10);

            // Assert
            Assert.Equal(1, list.Count);
            Assert.Equal(10, list.Front());
            Assert.Equal(10, list.Back());
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(100)]
        public void PushBack_AddsMultipleElements_MaintainsCorrectOrder(int count)
        {
            // Arrange
            var list = new DLL<int>();

            // Act
            for (int i = 0; i < count; i++)
            {
                list.PushBack(i);
            }

            // Assert
            Assert.Equal(count, list.Count);
            Assert.Equal(0, list.Front()); // First pushed is at front
            Assert.Equal(count - 1, list.Back()); // Last pushed is at back
        }

        [Fact]
        public void PushBack_WithNullValue_WorksForNullableTypes()
        {
            // Arrange
            var list = new DLL<string?>();

            // Act
            list.PushBack("test");
            list.PushBack(null);

            // Assert
            Assert.Equal(2, list.Count);
            Assert.Equal("test", list.Front());
            Assert.Null(list.Back());
        }

        [Fact]
        public void PushBack_WithDuplicates_AllowsMultipleSameValues()
        {
            // Arrange
            var list = new DLL<int>();

            // Act
            list.PushBack(7);
            list.PushBack(7);
            list.PushBack(7);

            // Assert
            Assert.Equal(3, list.Count);
            Assert.Equal(7, list.Front());
            Assert.Equal(7, list.Back());
        }

        #endregion

        #region PopFront Tests

        [Fact]
        public void PopFront_OnEmptyList_ThrowsInvalidOperationException()
        {
            // Arrange
            var list = new DLL<int>();

            // Act & Assert
            Assert.Throws<InvalidOperationException>(() => list.PopFront());
        }

        [Fact]
        public void PopFront_OnSingleElementList_ReturnsElementAndMakesListEmpty()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(42);

            // Act
            var result = list.PopFront();

            // Assert
            Assert.Equal(42, result);
            Assert.Equal(0, list.Count);
            Assert.True(list.IsEmpty());
        }

        [Fact]
        public void PopFront_RemovesElementsInCorrectOrder()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);
            list.PushBack(3);

            // Act & Assert
            Assert.Equal(1, list.PopFront());
            Assert.Equal(2, list.Count);
            Assert.Equal(2, list.PopFront());
            Assert.Equal(1, list.Count);
            Assert.Equal(3, list.PopFront());
            Assert.Equal(0, list.Count);
        }

        [Fact]
        public void PopFront_AfterMultiplePushes_MaintainsListIntegrity()
        {
            // Arrange
            var list = new DLL<int>();
            for (int i = 0; i < 10; i++)
            {
                list.PushBack(i);
            }

            // Act
            for (int i = 0; i < 5; i++)
            {
                list.PopFront();
            }

            // Assert
            Assert.Equal(5, list.Count);
            Assert.Equal(5, list.Front());
            Assert.Equal(9, list.Back());
        }

        #endregion

        #region PopBack Tests

        [Fact]
        public void PopBack_OnEmptyList_ThrowsInvalidOperationException()
        {
            // Arrange
            var list = new DLL<int>();

            // Act & Assert
            Assert.Throws<InvalidOperationException>(() => list.PopBack());
        }

        [Fact]
        public void PopBack_OnSingleElementList_ReturnsElementAndMakesListEmpty()
        {
            // Arrange
            var list = new DLL<string>();
            list.PushBack("only");

            // Act
            var result = list.PopBack();

            // Assert
            Assert.Equal("only", result);
            Assert.Equal(0, list.Count);
            Assert.True(list.IsEmpty());
        }

        [Fact]
        public void PopBack_RemovesElementsInCorrectOrder()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);
            list.PushBack(3);

            // Act & Assert
            Assert.Equal(3, list.PopBack());
            Assert.Equal(2, list.Count);
            Assert.Equal(2, list.PopBack());
            Assert.Equal(1, list.Count);
            Assert.Equal(1, list.PopBack());
            Assert.Equal(0, list.Count);
        }

        [Fact]
        public void PopBack_AfterMultiplePushes_MaintainsListIntegrity()
        {
            // Arrange
            var list = new DLL<int>();
            for (int i = 0; i < 10; i++)
            {
                list.PushBack(i);
            }

            // Act
            for (int i = 0; i < 5; i++)
            {
                list.PopBack();
            }

            // Assert
            Assert.Equal(5, list.Count);
            Assert.Equal(0, list.Front());
            Assert.Equal(4, list.Back());
        }

        #endregion

        #region Front Tests

        [Fact]
        public void Front_OnEmptyList_ThrowsInvalidOperationException()
        {
            // Arrange
            var list = new DLL<int>();

            // Act & Assert
            Assert.Throws<InvalidOperationException>(() => list.Front());
        }

        [Fact]
        public void Front_ReturnsFirstElement_WithoutRemoving()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);
            list.PushBack(3);

            // Act
            var result = list.Front();

            // Assert
            Assert.Equal(1, result);
            Assert.Equal(3, list.Count); // Size unchanged
        }

        [Fact]
        public void Front_AfterPushFront_ReturnsNewElement()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);

            // Act
            list.PushFront(0);

            // Assert
            Assert.Equal(0, list.Front());
        }

        #endregion

        #region Back Tests

        [Fact]
        public void Back_OnEmptyList_ThrowsInvalidOperationException()
        {
            // Arrange
            var list = new DLL<int>();

            // Act & Assert
            Assert.Throws<InvalidOperationException>(() => list.Back());
        }

        [Fact]
        public void Back_ReturnsLastElement_WithoutRemoving()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);
            list.PushBack(3);

            // Act
            var result = list.Back();

            // Assert
            Assert.Equal(3, result);
            Assert.Equal(3, list.Count); // Size unchanged
        }

        [Fact]
        public void Back_AfterPushBack_ReturnsNewElement()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);

            // Act
            list.PushBack(2);

            // Assert
            Assert.Equal(2, list.Back());
        }

        #endregion

        #region Contains Tests

        [Fact]
        public void Contains_OnEmptyList_ReturnsFalse()
        {
            // Arrange
            var list = new DLL<int>();

            // Act & Assert
            Assert.False(list.Contains(5));
        }

        [Theory]
        [InlineData(1)]
        [InlineData(5)]
        [InlineData(10)]
        public void Contains_WithExistingElement_ReturnsTrue(int value)
        {
            // Arrange
            var list = new DLL<int>();
            for (int i = 1; i <= 10; i++)
            {
                list.PushBack(i);
            }

            // Act & Assert
            Assert.True(list.Contains(value));
        }

        [Theory]
        [InlineData(0)]
        [InlineData(11)]
        [InlineData(-5)]
        public void Contains_WithNonExistingElement_ReturnsFalse(int value)
        {
            // Arrange
            var list = new DLL<int>();
            for (int i = 1; i <= 10; i++)
            {
                list.PushBack(i);
            }

            // Act & Assert
            Assert.False(list.Contains(value));
        }

        [Fact]
        public void Contains_WithDuplicates_ReturnsTrue()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(5);
            list.PushBack(5);
            list.PushBack(5);

            // Act & Assert
            Assert.True(list.Contains(5));
        }

        [Fact]
        public void Contains_WithNullInNullableList_ReturnsTrue()
        {
            // Arrange
            var list = new DLL<string?>();
            list.PushBack("a");
            list.PushBack(null);
            list.PushBack("b");

            // Act & Assert
            Assert.True(list.Contains(null));
        }

        [Fact]
        public void Contains_ChecksFirstElement()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);

            // Act & Assert
            Assert.True(list.Contains(1));
        }

        [Fact]
        public void Contains_ChecksLastElement()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);

            // Act & Assert
            Assert.True(list.Contains(2));
        }

        #endregion

        #region Remove Tests

        [Fact]
        public void Remove_OnEmptyList_ReturnsFalse()
        {
            // Arrange
            var list = new DLL<int>();

            // Act
            var result = list.Remove(5);

            // Assert
            Assert.False(result);
            Assert.Equal(0, list.Count);
        }

        [Fact]
        public void Remove_NonExistingElement_ReturnsFalse()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);
            list.PushBack(3);

            // Act
            var result = list.Remove(99);

            // Assert
            Assert.False(result);
            Assert.Equal(3, list.Count);
        }

        [Fact]
        public void Remove_ExistingElement_ReturnsTrueAndRemovesElement()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);
            list.PushBack(3);

            // Act
            var result = list.Remove(2);

            // Assert
            Assert.True(result);
            Assert.Equal(2, list.Count);
            Assert.False(list.Contains(2));
        }

        [Fact]
        public void Remove_FirstElement_UpdatesFrontCorrectly()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);
            list.PushBack(3);

            // Act
            list.Remove(1);

            // Assert
            Assert.Equal(2, list.Front());
            Assert.Equal(2, list.Count);
        }

        [Fact]
        public void Remove_LastElement_UpdatesBackCorrectly()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);
            list.PushBack(3);

            // Act
            list.Remove(3);

            // Assert
            Assert.Equal(2, list.Back());
            Assert.Equal(2, list.Count);
        }

        [Fact]
        public void Remove_OnlyElement_MakesListEmpty()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(42);

            // Act
            var result = list.Remove(42);

            // Assert
            Assert.True(result);
            Assert.True(list.IsEmpty());
            Assert.Equal(0, list.Count);
        }

        [Fact]
        public void Remove_WithDuplicates_RemovesOnlyFirstOccurrence()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(5);
            list.PushBack(5);
            list.PushBack(5);

            // Act
            var result = list.Remove(5);

            // Assert
            Assert.True(result);
            Assert.Equal(2, list.Count);
            Assert.True(list.Contains(5)); // Still contains duplicates
        }

        [Fact]
        public void Remove_NullFromNullableList_Works()
        {
            // Arrange
            var list = new DLL<string?>();
            list.PushBack("a");
            list.PushBack(null);
            list.PushBack("b");

            // Act
            var result = list.Remove(null);

            // Assert
            Assert.True(result);
            Assert.Equal(2, list.Count);
            Assert.False(list.Contains(null));
        }

        #endregion

        #region Clear Tests

        [Fact]
        public void Clear_OnEmptyList_RemainsEmpty()
        {
            // Arrange
            var list = new DLL<int>();

            // Act
            list.Clear();

            // Assert
            Assert.Equal(0, list.Count);
            Assert.True(list.IsEmpty());
        }

        [Fact]
        public void Clear_OnPopulatedList_RemovesAllElements()
        {
            // Arrange
            var list = new DLL<int>();
            for (int i = 0; i < 100; i++)
            {
                list.PushBack(i);
            }

            // Act
            list.Clear();

            // Assert
            Assert.Equal(0, list.Count);
            Assert.True(list.IsEmpty());
        }

        [Fact]
        public void Clear_AllowsReuse_AfterClearing()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);
            list.Clear();

            // Act
            list.PushBack(3);
            list.PushBack(4);

            // Assert
            Assert.Equal(2, list.Count);
            Assert.Equal(3, list.Front());
            Assert.Equal(4, list.Back());
        }

        #endregion

        #region Indexer Tests

        [Fact]
        public void Indexer_Get_ReturnsCorrectElements()
        {
            // Arrange
            var list = new DLL<int>();
            for (int i = 0; i < 10; i++)
            {
                list.PushBack(i);
            }

            // Act & Assert
            for (int i = 0; i < 10; i++)
            {
                Assert.Equal(i, list[i]);
            }
        }

        [Fact]
        public void Indexer_Get_AtIndex0_ReturnsFirstElement()
        {
            // Arrange
            var list = new DLL<string>();
            list.PushBack("first");
            list.PushBack("second");

            // Act & Assert
            Assert.Equal("first", list[0]);
        }

        [Fact]
        public void Indexer_Get_AtLastIndex_ReturnsLastElement()
        {
            // Arrange
            var list = new DLL<string>();
            list.PushBack("first");
            list.PushBack("last");

            // Act & Assert
            Assert.Equal("last", list[1]);
        }

        [Theory]
        [InlineData(-1)]
        [InlineData(10)]
        [InlineData(100)]
        public void Indexer_Get_OutOfRange_ThrowsException(int index)
        {
            // Arrange
            var list = new DLL<int>();
            for (int i = 0; i < 10; i++)
            {
                list.PushBack(i);
            }

            // Act & Assert
            Assert.Throws<ArgumentOutOfRangeException>(() => list[index]);
        }

        [Fact]
        public void Indexer_Set_UpdatesElement()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);
            list.PushBack(3);

            // Act
            list[1] = 99;

            // Assert
            Assert.Equal(99, list[1]);
            Assert.Equal(3, list.Count); // Size unchanged
        }

        [Fact]
        public void Indexer_Set_UpdatesFirstElement()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);

            // Act
            list[0] = 100;

            // Assert
            Assert.Equal(100, list.Front());
        }

        [Fact]
        public void Indexer_Set_UpdatesLastElement()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);

            // Act
            list[1] = 200;

            // Assert
            Assert.Equal(200, list.Back());
        }

        [Theory]
        [InlineData(-1)]
        [InlineData(5)]
        public void Indexer_Set_OutOfRange_ThrowsException(int index)
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);

            // Act & Assert
            Assert.Throws<ArgumentOutOfRangeException>(() => list[index] = 99);
        }

        #endregion

        #region Insert Tests

        [Fact]
        public void Insert_AtIndex0_InsertsAtFront()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(2);
            list.PushBack(3);

            // Act
            list.Insert(0, 1);

            // Assert
            Assert.Equal(3, list.Count);
            Assert.Equal(1, list.Front());
            Assert.Equal(1, list[0]);
        }

        [Fact]
        public void Insert_AtEnd_InsertsAtBack()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);

            // Act
            list.Insert(2, 3);

            // Assert
            Assert.Equal(3, list.Count);
            Assert.Equal(3, list.Back());
        }

        [Fact]
        public void Insert_InMiddle_InsertsCorrectly()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(3);

            // Act
            list.Insert(1, 2);

            // Assert
            Assert.Equal(3, list.Count);
            Assert.Equal(1, list[0]);
            Assert.Equal(2, list[1]);
            Assert.Equal(3, list[2]);
        }

        [Fact]
        public void Insert_IntoEmptyList_AtIndex0_Works()
        {
            // Arrange
            var list = new DLL<int>();

            // Act
            list.Insert(0, 42);

            // Assert
            Assert.Equal(1, list.Count);
            Assert.Equal(42, list.Front());
        }

        [Theory]
        [InlineData(-1)]
        [InlineData(4)]
        public void Insert_OutOfRange_ThrowsException(int index)
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);

            // Act & Assert
            Assert.Throws<ArgumentOutOfRangeException>(() => list.Insert(index, 99));
        }

        [Fact]
        public void Insert_Multiple_MaintainsCorrectOrder()
        {
            // Arrange
            var list = new DLL<int>();

            // Act
            list.Insert(0, 1);
            list.Insert(1, 3);
            list.Insert(1, 2);

            // Assert
            Assert.Equal(3, list.Count);
            Assert.Equal(1, list[0]);
            Assert.Equal(2, list[1]);
            Assert.Equal(3, list[2]);
        }

        #endregion

        #region IndexOf Tests

        [Fact]
        public void IndexOf_OnEmptyList_ReturnsNegativeOne()
        {
            // Arrange
            var list = new DLL<int>();

            // Act
            var result = list.IndexOf(5);

            // Assert
            Assert.Equal(-1, result);
        }

        [Fact]
        public void IndexOf_ExistingElement_ReturnsCorrectIndex()
        {
            // Arrange
            var list = new DLL<int>();
            for (int i = 0; i < 10; i++)
            {
                list.PushBack(i);
            }

            // Act & Assert
            for (int i = 0; i < 10; i++)
            {
                Assert.Equal(i, list.IndexOf(i));
            }
        }

        [Fact]
        public void IndexOf_NonExistingElement_ReturnsNegativeOne()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);
            list.PushBack(3);

            // Act
            var result = list.IndexOf(99);

            // Assert
            Assert.Equal(-1, result);
        }

        [Fact]
        public void IndexOf_WithDuplicates_ReturnsFirstOccurrence()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(5);
            list.PushBack(5);
            list.PushBack(5);
            list.PushBack(9);

            // Act
            var result = list.IndexOf(5);

            // Assert
            Assert.Equal(1, result); // First occurrence at index 1
        }

        [Fact]
        public void IndexOf_FirstElement_ReturnsZero()
        {
            // Arrange
            var list = new DLL<string>();
            list.PushBack("first");
            list.PushBack("second");

            // Act
            var result = list.IndexOf("first");

            // Assert
            Assert.Equal(0, result);
        }

        [Fact]
        public void IndexOf_LastElement_ReturnsLastIndex()
        {
            // Arrange
            var list = new DLL<string>();
            list.PushBack("first");
            list.PushBack("second");
            list.PushBack("third");

            // Act
            var result = list.IndexOf("third");

            // Assert
            Assert.Equal(2, result);
        }

        [Fact]
        public void IndexOf_Null_InNullableList_ReturnsCorrectIndex()
        {
            // Arrange
            var list = new DLL<string?>();
            list.PushBack("a");
            list.PushBack(null);
            list.PushBack("b");

            // Act
            var result = list.IndexOf(null);

            // Assert
            Assert.Equal(1, result);
        }

        #endregion

        #region RemoveAt Tests

        [Fact]
        public void RemoveAt_FirstElement_RemovesCorrectly()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);
            list.PushBack(3);

            // Act
            list.RemoveAt(0);

            // Assert
            Assert.Equal(2, list.Count);
            Assert.Equal(2, list.Front());
        }

        [Fact]
        public void RemoveAt_LastElement_RemovesCorrectly()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);
            list.PushBack(3);

            // Act
            list.RemoveAt(2);

            // Assert
            Assert.Equal(2, list.Count);
            Assert.Equal(2, list.Back());
        }

        [Fact]
        public void RemoveAt_MiddleElement_RemovesCorrectly()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);
            list.PushBack(3);

            // Act
            list.RemoveAt(1);

            // Assert
            Assert.Equal(2, list.Count);
            Assert.Equal(1, list[0]);
            Assert.Equal(3, list[1]);
        }

        [Theory]
        [InlineData(-1)]
        [InlineData(5)]
        public void RemoveAt_OutOfRange_ThrowsException(int index)
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(1);
            list.PushBack(2);

            // Act & Assert
            Assert.Throws<ArgumentOutOfRangeException>(() => list.RemoveAt(index));
        }

        [Fact]
        public void RemoveAt_OnlyElement_MakesListEmpty()
        {
            // Arrange
            var list = new DLL<int>();
            list.PushBack(42);

            // Act
            list.RemoveAt(0);

            // Assert
            Assert.True(list.IsEmpty());
        }

        #endregion

        #region Add Tests (IList interface)

        [Fact]
        public void Add_AddsElementToEnd()
        {
            // Arrange
            var list = new DLL<int>();

            // Act
            list.Add(1);
            list.Add(2);
            list.Add(3);

            // Assert
            Assert.Equal(3, list.Count);
            Assert.Equal(1, list[0]);
            Assert.Equal(2, list[1]);
            Assert.Equal(3, list[2]);
        }

        [Fact]
        public void Add_EquivalentToPushBack()
        {
            // Arrange
            var list1 = new DLL<int>();
            var list2 = new DLL<int>();

            // Act
            for (int i = 0; i < 10; i++)
            {
                list1.Add(i);
                list2.PushBack(i);
            }

            // Assert
            Assert.Equal(list1.Count, list2.Count);
            for (int i = 0; i < 10; i++)
            {
                Assert.Equal(list1[i], list2[i]);
            }
        }

        #endregion

        #region CopyTo Tests

        [Fact]
        public void CopyTo_NullArray_ThrowsArgumentNullException()
        {
            // Arrange
            var list = new DLL<int>();
            list.Add(1);

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => list.CopyTo(null!, 0));
        }

        [Fact]
        public void CopyTo_NegativeIndex_ThrowsArgumentOutOfRangeException()
        {
            // Arrange
            var list = new DLL<int>();
            list.Add(1);
            var array = new int[5];

            // Act & Assert
            Assert.Throws<ArgumentOutOfRangeException>(() => list.CopyTo(array, -1));
        }

        [Fact]
        public void CopyTo_InsufficientSpace_ThrowsArgumentException()
        {
            // Arrange
            var list = new DLL<int>();
            for (int i = 0; i < 10; i++)
            {
                list.Add(i);
            }
            var array = new int[5];

            // Act & Assert
            Assert.Throws<ArgumentException>(() => list.CopyTo(array, 0));
        }

        [Fact]
        public void CopyTo_ValidParameters_CopiesElementsCorrectly()
        {
            // Arrange
            var list = new DLL<int>();
            for (int i = 0; i < 5; i++)
            {
                list.Add(i);
            }
            var array = new int[10];

            // Act
            list.CopyTo(array, 0);

            // Assert
            for (int i = 0; i < 5; i++)
            {
                Assert.Equal(i, array[i]);
            }
        }

        [Fact]
        public void CopyTo_WithOffset_CopiesCorrectly()
        {
            // Arrange
            var list = new DLL<int>();
            list.Add(1);
            list.Add(2);
            list.Add(3);
            var array = new int[10];

            // Act
            list.CopyTo(array, 5);

            // Assert
            Assert.Equal(1, array[5]);
            Assert.Equal(2, array[6]);
            Assert.Equal(3, array[7]);
        }

        [Fact]
        public void CopyTo_EmptyList_DoesNotModifyArray()
        {
            // Arrange
            var list = new DLL<int>();
            var array = new int[] { 1, 2, 3, 4, 5 };
            var expectedArray = new int[] { 1, 2, 3, 4, 5 };

            // Act
            list.CopyTo(array, 0);

            // Assert
            Assert.Equal(expectedArray, array);
        }

        #endregion

        #region IEnumerable Tests

        [Fact]
        public void GetEnumerator_AllowsForeachIteration()
        {
            // Arrange
            var list = new DLL<int>();
            for (int i = 0; i < 10; i++)
            {
                list.Add(i);
            }

            // Act
            var results = new List<int>();
            foreach (var item in list)
            {
                results.Add(item);
            }

            // Assert
            Assert.Equal(10, results.Count);
            for (int i = 0; i < 10; i++)
            {
                Assert.Equal(i, results[i]);
            }
        }

        [Fact]
        public void GetEnumerator_OnEmptyList_NoIteration()
        {
            // Arrange
            var list = new DLL<int>();
            int count = 0;

            // Act
            foreach (var item in list)
            {
                count++;
            }

            // Assert
            Assert.Equal(0, count);
        }

        [Fact]
        public void GetEnumerator_WithLinq_Works()
        {
            // Arrange
            var list = new DLL<int>();
            for (int i = 1; i <= 10; i++)
            {
                list.Add(i);
            }

            // Act
            var evenNumbers = list.Where(x => x % 2 == 0).ToList();
            var sum = list.Sum();

            // Assert
            Assert.Equal(5, evenNumbers.Count);
            Assert.Equal(55, sum);
        }

        #endregion

        #region Size and Count Tests

        [Fact]
        public void Size_ReturnsCorrectCount()
        {
            // Arrange
            var list = new DLL<int>();

            // Assert initial
            Assert.Equal(0, list.Size());

            // Act & Assert
            list.PushBack(1);
            Assert.Equal(1, list.Size());
            list.PushBack(2);
            Assert.Equal(2, list.Size());
            list.PopFront();
            Assert.Equal(1, list.Size());
        }

        [Fact]
        public void Count_MatchesSize()
        {
            // Arrange
            var list = new DLL<int>();
            for (int i = 0; i < 10; i++)
            {
                list.Add(i);
            }

            // Act & Assert
            Assert.Equal(list.Size(), list.Count);
        }

        #endregion

        #region IsEmpty Tests

        [Fact]
        public void IsEmpty_OnNewList_ReturnsTrue()
        {
            // Arrange & Act
            var list = new DLL<int>();

            // Assert
            Assert.True(list.IsEmpty());
        }

        [Fact]
        public void IsEmpty_AfterAddingElements_ReturnsFalse()
        {
            // Arrange
            var list = new DLL<int>();

            // Act
            list.Add(1);

            // Assert
            Assert.False(list.IsEmpty());
        }

        [Fact]
        public void IsEmpty_AfterClear_ReturnsTrue()
        {
            // Arrange
            var list = new DLL<int>();
            list.Add(1);
            list.Add(2);

            // Act
            list.Clear();

            // Assert
            Assert.True(list.IsEmpty());
        }

        [Fact]
        public void IsEmpty_AfterRemovingAllElements_ReturnsTrue()
        {
            // Arrange
            var list = new DLL<int>();
            list.Add(1);

            // Act
            list.PopFront();

            // Assert
            Assert.True(list.IsEmpty());
        }

        #endregion

        #region IsReadOnly Tests

        [Fact]
        public void IsReadOnly_ReturnsFalse()
        {
            // Arrange
            var list = new DLL<int>();

            // Act & Assert
            Assert.False(list.IsReadOnly);
        }

        #endregion

        #region Complex Scenario Tests

        [Fact]
        public void ComplexScenario_MixedOperations_MaintainsIntegrity()
        {
            // Arrange
            var list = new DLL<int>();

            // Act & Assert - Complex sequence of operations
            list.PushBack(1);
            list.PushBack(2);
            list.PushFront(0);
            Assert.Equal(3, list.Count);
            Assert.Equal(0, list.Front());
            Assert.Equal(2, list.Back());

            list.PopFront();
            Assert.Equal(2, list.Count);
            Assert.Equal(1, list.Front());

            list.Insert(1, 99);
            Assert.Equal(3, list.Count);
            Assert.Equal(99, list[1]);

            list.Remove(99);
            Assert.Equal(2, list.Count);

            list.RemoveAt(0);
            Assert.Equal(1, list.Count);
            Assert.Equal(2, list.Front());
        }

        [Fact]
        public void StressTest_LargeNumberOfOperations()
        {
            // Arrange
            var list = new DLL<int>();
            const int iterations = 1000;

            // Act - Add many elements
            for (int i = 0; i < iterations; i++)
            {
                list.PushBack(i);
            }

            // Assert
            Assert.Equal(iterations, list.Count);
            Assert.Equal(0, list.Front());
            Assert.Equal(iterations - 1, list.Back());

            // Act - Remove half
            for (int i = 0; i < iterations / 2; i++)
            {
                list.PopFront();
            }

            // Assert
            Assert.Equal(iterations / 2, list.Count);
            Assert.Equal(iterations / 2, list.Front());
        }

        [Fact]
        public void AlternatingPushPop_MaintainsBalance()
        {
            // Arrange
            var list = new DLL<int>();

            // Act & Assert
            for (int i = 0; i < 100; i++)
            {
                list.PushBack(i);
                list.PushFront(i);
                
                if (i % 3 == 0)
                {
                    list.PopBack();
                }
                if (i % 5 == 0)
                {
                    list.PopFront();
                }
            }

            // Should still have elements and maintain structure
            Assert.True(list.Count > 0);
            Assert.NotEqual(list.Front(), list.Back());
        }

        [Fact]
        public void DifferentDataTypes_String_WorksCorrectly()
        {
            // Arrange
            var list = new DLL<string>();

            // Act
            list.Add("hello");
            list.Add("world");
            list.Add("test");

            // Assert
            Assert.Equal(3, list.Count);
            Assert.Equal("hello", list[0]);
            Assert.True(list.Contains("world"));
            Assert.Equal(2, list.IndexOf("test"));
        }

        [Fact]
        public void DifferentDataTypes_CustomObject_WorksCorrectly()
        {
            // Arrange
            var list = new DLL<Person>();
            var person1 = new Person { Name = "Alice", Age = 30 };
            var person2 = new Person { Name = "Bob", Age = 25 };

            // Act
            list.Add(person1);
            list.Add(person2);

            // Assert
            Assert.Equal(2, list.Count);
            Assert.Same(person1, list[0]);
            Assert.True(list.Contains(person2));
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(100)]
        public void PushAndPopCombinations_MaintainCorrectCount(int operations)
        {
            // Arrange
            var list = new DLL<int>();

            // Act
            for (int i = 0; i < operations; i++)
            {
                list.PushBack(i);
                list.PushFront(i);
            }

            // Assert
            Assert.Equal(operations * 2, list.Count);

            // Act - Remove all
            for (int i = 0; i < operations; i++)
            {
                list.PopFront();
                list.PopBack();
            }

            // Assert
            Assert.True(list.IsEmpty());
        }

        #endregion

        #region Edge Case Tests

        [Fact]
        public void SingleElement_AllOperations_WorkCorrectly()
        {
            // Arrange
            var list = new DLL<int>();
            list.Add(42);

            // Assert
            Assert.Equal(42, list.Front());
            Assert.Equal(42, list.Back());
            Assert.Equal(42, list[0]);
            Assert.True(list.Contains(42));
            Assert.Equal(0, list.IndexOf(42));
            Assert.Equal(1, list.Count);
        }

        [Fact]
        public void TwoElements_FrontAndBack_AreDifferent()
        {
            // Arrange
            var list = new DLL<int>();
            list.Add(1);
            list.Add(2);

            // Assert
            Assert.Equal(1, list.Front());
            Assert.Equal(2, list.Back());
            Assert.NotEqual(list.Front(), list.Back());
        }

        [Fact]
        public void AfterMultipleClears_ListRemainsUsable()
        {
            // Arrange
            var list = new DLL<int>();

            // Act & Assert
            for (int i = 0; i < 5; i++)
            {
                list.Add(1);
                list.Add(2);
                list.Add(3);
                Assert.Equal(3, list.Count);
                
                list.Clear();
                Assert.True(list.IsEmpty());
            }
        }

        #endregion
    }

    // Helper class for testing with custom objects
    public class Person
    {
        public string Name { get; set; } = "";
        public int Age { get; set; }
    }
}
